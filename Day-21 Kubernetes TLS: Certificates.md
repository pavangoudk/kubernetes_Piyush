# Kubernetes TLS: Certificates + CSR Workflow (CK 2024, Video 21)

## Context + what this video covers

# 

- This is **video #21** in the **CK 2024** series.
- Speaker references the previous video: basics of **SSL/TLS**, how it works, and securing client-to-server connections.
- This video focus: **TLS specifically for Kubernetes**:
- How TLS works across Kubernetes components
- How to create certificates
- How to create a **CertificateSigningRequest (CSR)**
- The end-to-end approval/issuance process (practical for Kubernetes work)

## Quick recap from previous video (only certificate flow)

# 
- Client certificates:
- *Client may need to “authenticate with the server” if the server asks the client to identify itself.*
- Server certificates:
- Server generates certificates + private key to enable secure communication.
- Certificate Authority (CA) role:
- Server requests certificate signing from a CA (examples given: Symantec, DigiCert).
- CA validates authenticity (e.g., checks server owns the domain), then issues the signed certificate.
- CSR mechanism:
- The server makes the request via a **CSR (certificate signing request)**.
- The CA signs/ issues certificates using *its own public certificate and private key pair*.
- The CA public certificate is installed in the client browser to validate:
- certificate is valid, not expired, issued by a valid authority, etc.

### Certificate types summarized

# 
- *“We have three types of certificates”*:
1. **Client certificates** (generated by the client)
2. **Root certificates** (generated/held by the certificate authority)
3. **Server certificates** (generated by the server for encryption/decryption)

## TLS in a Kubernetes cluster (who is client vs server)

# 
- Speaker uses a sample cluster:
- **Master node**
- **Multiple worker nodes**
- User/admin → **kube-apiserver**:
- The user is the **client**; **kube-apiserver** is the **server**
- Connection must be encrypted → certificates needed on both ends
- Master components ↔ worker nodes:
- Communication between master and worker nodes must also be encrypted
- Often driven by the **API server**
- Role-switch example:
- For external admin traffic: API server is **server**
- For API server talking to a node component (example given: **kubelet**): API server becomes the **client**, kubelet becomes the **server**
- Certificates are needed for each side accordingly
- Speaker notes you may reuse the API server certificate for multiple interactions or generate separate certs.

### Master node component interactions called out

# 
- **kube-apiserver** talks to:
- **etcd** (API server as client, etcd as server)
- **kubelet** (API server as client, kubelet as server)
- Other components talk to **kube-apiserver** as clients:
- **kube-scheduler** → API server (secure connection; scheduler needs cert/key)
- **controller-manager** → API server (secure connection; controller-manager needs cert/key)
- **kube-proxy** → API server (secure connection; kube-proxy needs cert/key)

## Naming/identifying public certs vs private keys

# 
- Speaker clarifies terminology so file names don’t confuse you:
- *“Anything that has CRT or PEM extension is a public certificate.”*
- *If you see “key” in the name or extension, it’s a private key.*
- Examples mentioned: `server.key`, `server-key.*`
- Memory rule given:
- *“If you see the word key… that means it’s a private key; else it’s a public certificate.”*

## ### Kubernetes Documentation (CertificateSigningRequests)

# 
- Speaker says they will follow Kubernetes docs:
- Go to Kubernetes documentation and search for **certificates**
- Use the page: **Certificates and Certificate Signing Requests**
- Scroll to the section: **“Create a certificate for the user / issue a certificate for the user”**
- Speaker keeps the doc open and follows steps in VS Code under a **day21** folder.

## Scenario used for the demo

# 
- Example: you are a Kubernetes cluster admin; a **new user** joins as another admin to share workload.
- You need to grant cluster access **using certificates**.

## ### OpenSSL (user-side: generate private key + CSR)

# 
Speaker frames this as steps the *new user* performs.

1. Generate a private key:
- Command described: `openssl genrsa -out <user>.key 2048`
- Example username: **adam**
- Output: `adam.key`
- Speaker reinforces: it’s private because it has **key** in the name.
2. Generate a CSR using that private key:
- Command described: `openssl req -new -key adam.key -out adam.csr -subj ...`
- Output: `adam.csr` (the CSR file)

## ### Kubernetes CSR object (admin-side: create CSR YAML)

# 
- User sends the **CSR** to the admin (not the private key).
- Admin creates a YAML file (speaker names it like `csr.yaml`).
- YAML includes:
- `apiVersion: certificates.k8s.io/...` (speaker notes Kubernetes provides this certificates API)
- `kind: CertificateSigningRequest`
- `metadata.name: adam`
- `spec.request:` (the CSR content, but must be Base64-encoded)

### Base64 encoding requirement (CSR must be one line)

# 
- Speaker notes:
- CSR text in `adam.csr` is plain text with line breaks.
- In the Kubernetes CSR object, it must be **Base64 encoded** and in **one single line**.
- Command approach shown:
- `cat adam.csr | base64 | tr -d '\n'`
- Paste the resulting one-line Base64 string into `spec.request`.

### Expiration

# 
- Field mentioned: `expirationSeconds`
- *Means after these many seconds the certificate will be expired.*
- Speaker says certificates are often kept about a year, customizable, and you can remove the line if you want.

## Create and inspect the CSR in Kubernetes

# 
1. Apply the CSR YAML:
- `kubectl apply -f csr.yaml`
- Output: CSR created
2. List CSRs:
- `kubectl get certificatesigningrequest` (or short form `kubectl get csr`)
- Status shown: **Pending** (because not approved yet)

## Internal CA in Kubernetes (how approval works)

# 
- Speaker explains:
- For an internal Kubernetes cluster, you typically use an **internal CA** (not a public CA).
- Internal CA may be on a server; “by default” hosted on the **master server** (as stated).
- Internal CA is effectively the **public certificate + private key** already present on the node, used as the certificate authority.
- Permissions note:
- Approving/denying requires specific permissions/roles.
- Speaker points to the doc for required role details but does not cover it yet (roles/role bindings not covered in their series at this point).

## Approve or deny the CSR

# 
- Describe CSR to review details:
- `kubectl describe csr adam`
- Speaker calls out fields like:
- Status pending
- Name adam
- Signer name (mentioned as kube-apiserver client signer)
- Requesting user (mentioned as Kubernetes admin), etc.
- Approve command shown:
- `kubectl certificate approve adam`
- After approval:
- `kubectl get csr` shows **Approved, Issued**

## Extract the issued certificate and share with the user

# 
1. Export CSR object YAML:
- `kubectl get csr adam -o yaml > issued.yaml`
2. The issued certificate appears in the output under the certificate field (still encoded).
3. Decode the issued certificate for the user:
- `echo <base64> | base64 -d` (or `--decode`)
- This produces the plaintext certificate.
4. Next steps mentioned but not shown:
- Add the certificate into **kubeconfig**
- Assign roles so the user has the right permissions
- Speaker defers details until roles/kubeconfig topics are covered.

## Wrap-up + why this matters (exam relevance)

# 
- Speaker summarizes what you learned:
- TLS in Kubernetes component-to-component communication
- Certificate types, public vs private key distinction
- Creating CSR, approving/denying it, and sharing the issued cert
- Using the Kubernetes **certificates API** and `kubectl` commands
- Speaker says this is important for administrators and expects at least one exam task on it.
- Mentions there’s a task in the GitHub **day21** folder for hands-on practice and support via comments/Discord.

#